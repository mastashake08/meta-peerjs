<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest/Mobile AR Game</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Vue 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- PeerJS -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <!-- Three.js for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        body { background-color: #1a1a1a; color: #f0f0f0; font-family: 'Inter', sans-serif; overflow: hidden; }
        video { width: 100%; height: 100%; object-fit: cover; }
        #ar-canvas { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 10; }
        #remote-video { display: none; } /* Video is rendered to canvas, not shown directly */
        .uppercase-input::placeholder { text-transform: none; }
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            border: 2px solid rgba(0, 255, 255, 0.7);
            border-radius: 50%;
            z-index: 20;
        }
        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background-color: rgba(0, 255, 255, 0.7);
        }
        .crosshair::before { width: 2px; height: 10px; top: -6px; left: 12px; }
        .crosshair::after { height: 2px; width: 10px; left: -6px; top: 12px; }
    </style>
</head>
<body class="antialiased">

    <div id="app" class="min-h-screen flex flex-col items-center justify-center">
        
        <div v-if="loading" class="text-center"><h1 class="text-3xl font-bold text-cyan-400">Loading...</h1></div>

        <div v-if="appMode === 'selection'" class="text-center space-y-8 p-4">
            <h1 class="text-4xl font-bold tracking-tight">Quest/Mobile AR Game</h1>
            <div class="flex flex-col md:flex-row gap-4 justify-center">
                <button @click="startAsCaller" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg">Mobile Device (Player)</button>
                <button @click="startAsReceiver" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg">Meta Quest (Shooter)</button>
            </div>
            <p class="text-sm text-gray-500 pt-8 max-w-md mx-auto"><strong>Instructions:</strong> Mobile player navigates to the target. Quest player shoots cubes.</p>
        </div>

        <!-- Caller (Mobile) View -->
        <div v-if="appMode === 'caller'" class="w-full max-w-lg text-center p-4">
            <h2 class="text-2xl font-bold text-blue-400 mb-2">Mobile Player</h2>
            <div v-if="!isConnected" class="space-y-4">
                <input v-model="remotePeerId" @input="remotePeerId = remotePeerId.toUpperCase()" maxlength="6" type="text" placeholder="Enter 6-Character Quest ID" class="w-full p-3 bg-gray-700 rounded-lg text-center tracking-widest font-mono text-lg">
                <button @click="makeCall" :disabled="!remotePeerId || !peerId || remotePeerId.length !== 6" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg disabled:bg-gray-600">Call Meta Quest</button>
            </div>
            <div v-if="statusMessage" class="mt-4 p-3 rounded-lg" :class="errorMessage ? 'bg-red-900/50 text-red-300' : 'bg-gray-700/50 text-gray-300'">{{ statusMessage }}</div>
            
            <div v-if="isConnected" class="mt-4 text-left bg-gray-800 p-4 rounded-lg">
                <div v-if="gameState.gameStatus === 'won'" class="text-center p-8">
                    <h3 class="text-4xl font-bold text-green-400">YOU WIN!</h3>
                    <p class="text-lg">You reached the target location.</p>
                </div>
                <div v-else>
                    <h3 class="text-lg font-semibold text-green-400 pb-2 mb-2">Objective: Navigate to Target</h3>
                    <p class="text-2xl font-mono">Distance to Target: <strong>{{ distanceToTarget.toFixed(0) }} meters</strong></p>
                    <div class="mt-4 p-4 bg-gray-900 rounded-lg h-64 w-64 mx-auto relative overflow-hidden" id="radar">
                        <!-- Player Icon -->
                        <div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-4 h-4 bg-cyan-400 rounded-full border-2 border-white"></div>
                        <!-- Target Icon -->
                        <div v-if="gameState.targetGps" class="absolute" :style="getTargetPositionOnRadar">
                           <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-yellow-400" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" /></svg>
                        </div>
                        <!-- Cube Icons -->
                        <div v-for="cube in gameState.cubes" :key="cube.id" class="absolute w-3 h-3 bg-red-500 rounded-full" :style="getCubePositionOnRadar(cube)"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Receiver (Meta Quest) View -->
        <div v-if="appMode === 'receiver'" class="w-full h-screen">
            <div v-if="!isConnected" class="w-full h-full flex flex-col items-center justify-center">
                <h2 class="text-3xl font-bold text-purple-400 mb-4">Meta Quest (Shooter)</h2>
                <p class="text-lg text-gray-300 mb-2">Your 6-Character Peer ID:</p>
                <div class="bg-gray-800 p-4 rounded-lg inline-block shadow-lg">
                    <p class="text-4xl font-mono tracking-widest uppercase">{{ peerId || '...' }}</p>
                </div>
                <p class="mt-4 text-gray-400">{{ statusMessage }}</p>
            </div>
             
            <div v-if="isConnected && !arReady" class="w-full h-full flex items-center justify-center text-center">
                <div>
                    <button @click="startARSession" :disabled="!videoReady" class="bg-green-600 hover:bg-green-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-4 px-8 rounded-lg text-2xl shadow-lg">Start AR</button>
                    <p v-if="!videoReady" class="text-gray-400 mt-4">Waiting for video stream from mobile device...</p>
                </div>
            </div>

            <div v-if="isConnected && arReady" class="w-full h-full relative">
                <canvas id="ar-canvas"></canvas>
                <div class="crosshair"></div>
                <div class="absolute bottom-8 left-8 bg-black/60 p-4 rounded-lg text-white font-mono shadow-xl text-sm">
                    <h3 class="text-lg font-bold text-cyan-300 mb-2">Mobile Player GPS</h3>
                    <span>Lat: {{ gpsData.lat?.toFixed(5) || '...' }}</span><br/>
                    <span>Lon: {{ gpsData.lon?.toFixed(5) || '...' }}</span>
                </div>
                 <div class="absolute top-8 right-8 bg-black/60 p-4 rounded-lg text-white font-mono shadow-xl text-center">
                    <h3 class="text-lg font-bold text-yellow-400">TARGET DISTANCE</h3>
                    <p class="text-3xl">{{ distanceToTarget.toFixed(0) }} m</p>
                </div>
                <div class="absolute top-8 left-8 bg-black/60 p-4 rounded-lg text-white font-mono shadow-xl text-center">
                    <h3 class="text-lg font-bold text-red-400">CUBES REMAINING</h3>
                    <p class="text-3xl">{{ gameState.cubes.length }}</p>
                </div>
                <div v-if="gameState.gameStatus === 'won'" class="absolute inset-0 bg-black/80 flex items-center justify-center z-50">
                     <h3 class="text-6xl font-bold text-green-400">TARGET REACHED!</h3>
                </div>
            </div>
        </div>
        
        <video ref="remoteVideo" id="remote-video" autoplay playsinline></video>
    </div>

    <script type="module">
        const { createApp, ref, onMounted, watch, computed } = Vue;

        createApp({
            setup() {
                const loading = ref(true);
                const appMode = ref('selection');
                const statusMessage = ref('');
                const errorMessage = ref('');
                
                const peer = ref(null);
                const peerId = ref('');
                const remotePeerId = ref('');
                const conn = ref(null);
                const isConnected = ref(false);
                const arReady = ref(false);
                const videoReady = ref(false);
                
                const localStream = ref(null);
                const remoteStream = ref(null);
                const remoteVideo = ref(null);
                
                const gpsData = ref({});
                let gpsWatchId = null;

                const gameState = ref({
                    targetGps: null,
                    cubes: [],
                    gameStatus: 'playing',
                    score: 0,
                });
                
                let scene, camera, renderer, videoTexture, cubeMeshes = [], projectiles = [], controller, clock;

                const distanceToTarget = computed(() => {
                    if (gameState.value.targetGps && gpsData.value.lat) {
                        return calculateDistance(gpsData.value.lat, gpsData.value.lon, gameState.value.targetGps.lat, gameState.value.targetGps.lon);
                    }
                    return 0;
                });

                const getTargetPositionOnRadar = computed(() => getRadarPosition(gameState.value.targetGps));
                const getCubePositionOnRadar = (cube) => getRadarPosition({ lat: cube.lat, lon: cube.lon });
                
                function getRadarPosition(targetCoords) {
                    if (!targetCoords || !gpsData.value.lat) return { top: '50%', left: '50%'};
                    const distance = calculateDistance(gpsData.value.lat, gpsData.value.lon, targetCoords.lat, targetCoords.lon);
                    const bearing = calculateBearing(gpsData.value.lat, gpsData.value.lon, targetCoords.lat, targetCoords.lon);
                    
                    const radarRadius = 112;
                    const maxDistance = 2000;
                    const displayDistance = Math.min(distance, maxDistance) / maxDistance * radarRadius;

                    const angleRad = (bearing - 90) * (Math.PI / 180);
                    const x = displayDistance * Math.cos(angleRad);
                    const y = displayDistance * Math.sin(angleRad);

                    return {
                        top: `calc(50% + ${y}px)`,
                        left: `calc(50% + ${x}px)`,
                        transform: 'translate(-50%, -50%)',
                    };
                }

                function calculateDistance(lat1, lon1, lat2, lon2) {
                    const R = 6371e3;
                    const φ1 = lat1 * Math.PI/180, φ2 = lat2 * Math.PI/180;
                    const Δφ = (lat2-lat1) * Math.PI/180, Δλ = (lon2-lon1) * Math.PI/180;
                    const a = Math.sin(Δφ/2)**2 + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ/2)**2;
                    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                    return R * c;
                }

                function calculateBearing(lat1, lon1, lat2, lon2) {
                    const φ1 = lat1 * Math.PI/180, φ2 = lat2 * Math.PI/180;
                    const λ1 = lon1 * Math.PI/180, λ2 = lon2 * Math.PI/180;
                    const y = Math.sin(λ2-λ1) * Math.cos(φ2);
                    const x = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(λ2-λ1);
                    const θ = Math.atan2(y, x);
                    return (θ*180/Math.PI + 360) % 360;
                }

                function generateRandomPoint(lat, lon, distanceMeters) {
                    const R = 6371e3;
                    const d = distanceMeters;
                    const brng = Math.random() * 2 * Math.PI;
                    const lat1 = lat * Math.PI/180, lon1 = lon * Math.PI/180;
                    const lat2 = Math.asin(Math.sin(lat1)*Math.cos(d/R) + Math.cos(lat1)*Math.sin(d/R)*Math.cos(brng));
                    const lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(d/R)*Math.cos(lat1), Math.cos(d/R)-Math.sin(lat1)*Math.sin(lat2));
                    return { lat: lat2 * 180/Math.PI, lon: lon2 * 180/Math.PI };
                }

                const initializePeer = (id) => {
                    peer.value = new Peer(id);
                    peer.value.on('open', (openId) => peerId.value = openId);
                    peer.value.on('error', (err) => { statusMessage.value = `Error: ${err.message}`; errorMessage.value = true; });
                    if (appMode.value === 'receiver') setupReceiverListeners();
                };

                const setupReceiverListeners = () => {
                    statusMessage.value = 'Waiting for connection...';
                    peer.value.on('connection', (dataConnection) => {
                        conn.value = dataConnection;
                        conn.value.on('open', () => { isConnected.value = true; statusMessage.value = "Connected!"; });
                        conn.value.on('data', handleData);
                    });
                    peer.value.on('call', async (call) => {
                        const questMicStream = await navigator.mediaDevices.getUserMedia({ video: false, audio: true });
                        call.answer(questMicStream);
                        call.on('stream', (stream) => {
                            remoteStream.value = stream;
                            remoteVideo.value.srcObject = stream;
                            remoteVideo.value.play();
                        });
                    });
                };
                
                const makeCall = async () => {
                    try {
                        const mobileStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: true });
                        localStream.value = mobileStream;
                        conn.value = peer.value.connect(remotePeerId.value);
                        conn.value.on('open', () => { isConnected.value = true; startGpsUpdates(); });
                        conn.value.on('data', handleData);
                        peer.value.call(remotePeerId.value, mobileStream);
                    } catch (err) { statusMessage.value = "Error: " + err.message; errorMessage.value = true; }
                };
                
                const startGpsUpdates = () => {
                    gpsWatchId = navigator.geolocation.watchPosition(
                        (pos) => {
                            const { latitude, longitude } = pos.coords;
                            gpsData.value = { lat: latitude, lon: longitude };
                            sendData({ type: 'gpsUpdate', payload: gpsData.value });
                        }, () => {}, { enableHighAccuracy: true }
                    );
                };
                
                const sendData = (data) => { if (conn.value?.open) conn.value.send(data); };
                
                const handleData = (data) => {
                    if (appMode.value === 'receiver' && data.type === 'gpsUpdate') {
                        gpsData.value = data.payload;
                        if (!gameState.value.targetGps) {
                           initializeGame(data.payload.lat, data.payload.lon);
                        } else {
                           updateARScene();
                           if(distanceToTarget.value < 1000 && gameState.value.gameStatus !== 'won') {
                               gameState.value.gameStatus = 'won';
                               sendData({ type: 'gameState', payload: gameState.value });
                           }
                        }
                    }
                    if (appMode.value === 'caller' && data.type === 'gameState') {
                        gameState.value = data.payload;
                    }
                };

                const initializeGame = (startLat, startLon) => {
                    gameState.value.targetGps = generateRandomPoint(startLat, startLon, 1500);
                    gameState.value.cubes = [...Array(5)].map((_, i) => ({
                        id: `cube_${i}`, ...generateRandomPoint(startLat, startLon, Math.random() * 500)
                    }));
                    gameState.value.gameStatus = 'playing';
                    sendData({ type: 'gameState', payload: gameState.value });
                    if (arReady.value) spawnCubesAR();
                };

                async function startARSession() {
                    const canvas = document.getElementById('ar-canvas');
                    console.log(canvas);
                    try {
                    renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    renderer.xr.enabled = true;
                    
                    scene = new THREE.Scene();
                    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                    } catch (e) {
                        console.log(e);
                    }
                    videoTexture = new THREE.VideoTexture(remoteVideo.value);
                    scene.background = videoTexture;
                    
                    const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
                    scene.add(light);

                    clock = new THREE.Clock();

                    controller = renderer.xr.getController(0);
                    controller.addEventListener('select', shoot);
                    scene.add(controller);
                    
                    try {
                        const session = await navigator.xr.requestSession('immersive-vr', { optionalFeatures: ['local-floor', 'bounded-floor'] });
                        await renderer.xr.setSession(session);
                        arReady.value = true;
                        
                        if (gameState.value.cubes.length > 0) spawnCubesAR();
                        renderer.setAnimationLoop(animateAR);
                    } catch (e) {
                        statusMessage.value = "Failed to start AR session.";
                        console.error(e);
                    }
                }

                function spawnCubesAR() {
                    const geometry = new THREE.BoxGeometry();
                    const material = new THREE.MeshStandardMaterial({ color: 0xff00ff, roughness: 0.3 });
                    gameState.value.cubes.forEach(cubeData => {
                        const cube = new THREE.Mesh(geometry, material);
                        cube.userData.id = cubeData.id;
                        cubeMeshes.push(cube);
                        scene.add(cube);
                    });
                    updateARScene();
                }

                function updateARScene() {
                    if (!gpsData.value.lat || !renderer?.xr.isPresenting) return;
                    cubeMeshes.forEach(mesh => {
                        const cubeData = gameState.value.cubes.find(c => c.id === mesh.userData.id);
                        if(cubeData) {
                            const bearing = calculateBearing(gpsData.value.lat, gpsData.value.lon, cubeData.lat, cubeData.lon);
                            const angleRad = (bearing * Math.PI / 180);
                            const displayDistance = 15;
                            mesh.position.set(displayDistance * Math.sin(angleRad), (Math.random() - 0.5) * 5, -displayDistance * Math.cos(angleRad));
                        }
                    });
                }
                
                function shoot() {
                    if(!renderer?.xr.isPresenting) return;
                    
                    const projectileGeo = new THREE.SphereGeometry(0.1, 8, 8);
                    const projectileMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, toneMapped: false });
                    const projectile = new THREE.Mesh(projectileGeo, projectileMat);
                    
                    const velocity = new THREE.Vector3(0, 0, -1);
                    velocity.applyQuaternion(controller.quaternion);
                    
                    projectile.position.copy(controller.position);
                    projectile.userData.velocity = velocity;
                    projectile.userData.speed = 20; // units per second
                    projectiles.push(projectile);
                    scene.add(projectile);
                }

                function animateAR(time, frame) {
                    if (!renderer?.xr.isPresenting) return;
                    
                    const delta = clock.getDelta();

                    projectiles.forEach((p, index) => {
                        const moveDistance = p.userData.speed * delta;
                        p.position.addScaledVector(p.userData.velocity, moveDistance);

                        if(p.position.length() > 100) {
                           scene.remove(p);
                           projectiles.splice(index, 1);
                        } else {
                           // Collision detection
                           for (let i = cubeMeshes.length - 1; i >= 0; i--) {
                               const cube = cubeMeshes[i];
                               if (p.position.distanceTo(cube.position) < 1.0) {
                                   scene.remove(cube);
                                   cubeMeshes.splice(i, 1);
                                   scene.remove(p);
                                   projectiles.splice(index, 1);

                                   const cubeId = cube.userData.id;
                                   gameState.value.cubes = gameState.value.cubes.filter(c => c.id !== cubeId);
                                   gameState.value.score++;
                                   sendData({ type: 'gameState', payload: gameState.value });
                                   break; // Exit inner loop since projectile is gone
                               }
                           }
                        }
                    });

                    if (videoTexture) videoTexture.needsUpdate = true;
                    cubeMeshes.forEach(mesh => mesh.rotation.y += 0.01);
                    renderer.render(scene, camera);
                }

                const startAs = (mode) => {
                    appMode.value = mode;
                    const id = [...Array(6)].map(() => "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"[Math.floor(Math.random() * 36)]).join('');
                    initializePeer(id);
                };

                onMounted(() => {
                    loading.value = false;
                    if (remoteVideo.value) {
                         remoteVideo.value.addEventListener('playing', () => {
                            console.log("Remote video has started playing.");
                            videoReady.value = true;
                        });
                    }
                });

                return {
                    loading, appMode, peerId, remotePeerId, isConnected, arReady, videoReady, statusMessage, errorMessage,
                    startAsCaller: () => startAs('caller'),
                    startAsReceiver: () => startAs('receiver'),
                    makeCall, startARSession,
                    gpsData, gameState, distanceToTarget, getTargetPositionOnRadar, getCubePositionOnRadar, remoteVideo,
                };
            }
        }).mount('#app');
    </script>
</body>
</html>

